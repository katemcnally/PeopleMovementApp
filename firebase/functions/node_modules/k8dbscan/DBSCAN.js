/* 
@constructor 

@param {Array} dataset
@param {number} epsilon
@param {number} minPts
@param (function) dist
@returns {DBSCAN}

*/

function DBSCAN(dataset, epsilon, minPts, dist){
	this.dataset = [];
	this.epsilon = 1;
	this.minPts = 2;
	this.distance = this._euclideanDist;
	this.clusters = [];
	this.noise = [];

	this._visited = [];
	this._assigned = [];
	this._datasetLength = 0;

	this._init(dataset, epsilon, minPts, dist);
};

//***** clustering algorithm to call ******
DBSCAN.prototype.run = function(dataset, epsilon, minPts, dist) {
	this._init(dataset, epsilon, minPts, dist);

	for(var pointID = 0; pointID<this._datasetLength; pointID++){
		//change point id to lat and lon for each point
		//if not visited, check if it forms a cluster
		if(this._visited[pointID] != 1){
			this._visited[pointID] = 1;

			var neighbors = this._regionQuery(pointID);

			if(neighbors.length < this.minPts){ //min points will be whatever max cluster size we want to trigger on
				this.noise.push(pointID);
			}
			else{
				//create new cluster and add this point
				var clusterID = this.clusters.length;
				this.clusters.push([]);
				this._addToCluster(pointID, clusterID);

				this._expandCluster(clusterID, neighbors);
			}
		}
	}
	return this.clusters;
};

// ***** initializing parameters ******
DBSCAN.prototype._init = function(dataset, epsilon, minPts, distance) {
	
	if(dataset){
		if(!(dataset instanceof Array)){
			throw Error('Dataset must be an array');
		}

		this.dataset = dataset;
		this.clusters = [];
		this.noise = [];

		this._datasetLength = dataset.length;
		this._visited = new Array(this._datasetLength);
		this._assigned = new Array(this._datasetLength);
	}

	if(epsilon){
		this.epsilon = epsilon;
	}

	if(minPts){
		this.minPts = minPts;
	}

	if(distance){
		this.distance = distance;
	}
};

DBSCAN.prototype._expandCluster = function(clusterID, neighbors) {
	
	for(var i = 0; i<neighbors.length; i++){
		var pointID2 = neighbors[i];

		if(this._visited[pointID2] != 1){
			this._visited[pointID2] = 1;
			var neighbors2 = this._regionQuery(pointID2);

			if(neighbors2.length >= this.minPts){
				neighbors = this._mergeArrays(neighbors, neighbors2);
			}
		}

		//adding to the cluster
		if(this._assigned[pointID2] != 1){
			this._addToCluster(pointID2, clusterID);
		}
	}
};

DBSCAN.prototype._addToCluster = function(pointID, clusterID){
	this.clusters[clusterID].push(pointID);
	this._assigned[pointID] = 1;
}

DBSCAN.prototype._regionQuery = function(pointID) {
	var neighbors = [];
	for(var id = 0; id < this._datasetLength; id++){
		var dist = this.distance(this.dataset[pointID], this.dataset[id]);
		if(dist < this.epsilon){
			neighbors.push(id);
		}
	}
	return neighbors;
};


DBSCAN.prototype._mergeArrays = function(a,b) {

	for(var i = 0; i<b.length; i++){
		var p = b[i];
		//if b[i] does not exist in a, then add it
		if(a.indexOf(p) < 0){
			a.push(p);
		}
	}
	//a is the merged array
	return a;
};


DBSCAN.prototype._euclideanDist = function(p, q){
	var sum = 0;
	var i = Math.min(p.length, q.length)

	while(i--){
		sum += (p[i] - q[i]) * (p[i] - q[i]);
	}

	return Math.sqrt(sum);
};











